<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: EntityManager.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: EntityManager.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import omit from 'lodash/object/omit';
import find from 'lodash/collection/find';
import sortByAll from 'lodash/collection/sortByAll';

import QuerySet from './QuerySet';
import Entity from './Entity';
import {
    CREATE,
    UPDATE,
    DELETE,
    ORDER,
} from './constants';
import {match} from './utils.js';

const DEFAULT_SCHEMA_OPTIONS = {
    name: 'items',
    idAttribute: 'id',
};

/**
 * A class that manages an entity tree branch.
 *
 * The manager shares the following methods with {@link QuerySet}:
 *
 * - [getPlainEntities]{@link QuerySet#getPlainEntities}
 * - [all]{@link QuerySet#all}
 * - [filter]{@link QuerySet#filter}
 * - [exclude]{@link QuerySet#exclude}
 * - [orderBy]{@link QuerySet#orderBy}
 * - [exists]{@link QuerySet#exists}
 * - [first]{@link QuerySet#first}
 * - [last]{@link QuerySet#last}
 * - [at]{@link QuerySet#at}
 * - [delete]{@link QuerySet#delete}
 * - [update]{@link QuerySet#update}
 *
 */
const EntityManager = class EntityManager {
    /**
     * Create an EntityManager.
     * @param  {object} [tree] - the tree branch to manage. If `tree` is `undefined`, `reduce` will return
     *                           create an empty state tree based on the schema before applying any mutations.
     */
    constructor(tree) {
        Object.assign(this, {
            tree,
            mutations: [],
        });

        this.schema = this._initializeSchema();

        if (!this.tree) {
            this.tree = this.getDefaultState();
        }
    }


    _initializeSchema() {
        let schema;
        if (typeof this.schema === 'string') {
            schema = Object.assign({}, DEFAULT_SCHEMA_OPTIONS, {name: this.schema});
        } else if (this.schema) {
            schema = Object.assign({}, DEFAULT_SCHEMA_OPTIONS, this.schema);
        } else {
            schema = DEFAULT_SCHEMA_OPTIONS;
        }

        if (!schema.arrName) {
            schema.arrName = schema.name;
        }

        if (!schema.mapName) {
            schema.mapName = schema.name + 'ById';
        }

        return schema;
    }

    /**
     * Returns the default state tree.
     * If no tree is specified when instantiating an EntityManager,
     * this will be called in the constructor.
     * @return {Object} The state tree as described in the schema.
     */
    getDefaultState() {
        return {
            [this.arrName]: [],
            [this.mapName]: {},
        };
    }

    getEntityMap() {
        return this.tree[this.schema.mapName];
    }

    getIdArray() {
        return this.tree[this.schema.arrName];
    }

    getId(id) {
        return this.getEntityMap()[id];
    }

    getPlainEntity(id, includeIdAttribute) {
        let entity = this.getId(id);

        if (!!includeIdAttribute) {
            entity = Object.assign({[this.schema.idAttribute]: id}, entity);
        }

        return entity;
    }

    getPlainEntityWithId(id) {
        return this.getPlainEntity(id, true);
    }

    /**
     * Returns the id to be assigned to a new entity.
     * You may override this to suit your needs.
     * @return {*} the id value for a new entity.
     */
    nextId() {
        return Math.max(...this.getIdArray()) + 1;
    }

    getQuerySet() {
        const QuerySetClass = this.querySetClass;
        return new QuerySetClass(this, this.getIdArray(), {entityClass: this.entityClass});
    }

    /**
     * Returns a QuerySet containing all entities.
     * @return {QuerySet} a QuerySet containing all entities
     */
    all() {
        return this.getQuerySet();
    }

    /**
     * Records the addition of a new entity and returns a
     * new Entity instance. If you specify an id in
     * `props[this.schema.idAttribute]`, it will be used as the
     * id for the new Entity. Otherwise it will be generated by
     * [nextId]{@link EntityManager#nextId}
     *
     * @param  {props} props - the new Entity's properties.
     * @return {Entity} a new Entity instance.
     */
    create(props) {
        this.mutations.push({
            type: CREATE,
            payload: props,
        });
        return new Entity(this, props);
    }

    /**
     * Gets the Entity instance that matches properties in `lookupObj`.
     * Throws an error if Entity is not found.
     *
     * @param  {Object} lookupObj - the properties used to match a single entity.
     * @return {Entity} an Entity instance that matches `lookupObj` properties.
     */
    get(lookupObj) {
        if (!this.getIdArray().length) {
            throw new Error('Tried getting from empty QuerySet');
        }

        const keys = Object.keys(lookupObj);
        if (keys.includes(this.idAttribute)) {
            // We treat `idAttribute` as unique, so if it's
            // in `lookupObj` we search with that attribute only.
            return new Entity(this, this.getPlainEntity(lookupObj[this.idAttribute]), true);
        }
        const found = find(this.getPlainEntities(), entity => match(lookupObj, entity));

        if (!found) {
            throw new Error('Entity not found when calling get method');
        }

        return new Entity(this, found);
    }

    /**
     * Records an ordering mutation for the entities.
     * Note that if you create or update any entities after
     * calling this, they won't be in order.
     *
     * See the shared {@link QuerySet} method [orderBy]{@link QuerySet#orderBy}
     * that returns an ordered {@link QuerySet}.
     *
     * @param {function|string|string[]} orderArg - A function, an attribute name or a list of attribute
     *                                              names to order the entities by. If you supply a function,
     *                                              it must return a value user to order the entities.
     * @return {undefined}
     */
    setOrder(orderArg) {
        this.mutations.push({
            type: ORDER,
            payload: orderArg,
        });
    }

    /**
     * Applies recorded mutations and returns a new state tree.
     * @return {Object} the reduced state tree
     */
    reduce() {
        const {
            arrName,
            mapName,
        } = this.schema;

        return this.mutations.reduce((state, action) => {
            switch (action.type) {
            case CREATE:
            case DELETE:
                // These mutation types operate on both the idArray and entityMap.
                return {
                    [arrName]: this.reduceIdArray(state[arrName], action),
                    [mapName]: this.reduceEntityMap(state[mapName], action),
                };
            case ORDER:
                // Order mutates only the id array.
                return {
                    [arrName]: this.reduceIdArray(state[arrName], action),
                    [mapName]: state[mapName],
                };
            case UPDATE:
                // Update mutates only the entityMap, since we don't allow
                // for updating id's.
                return {
                    [arrName]: state[arrName],
                    [mapName]: this.reduceEntityMap(state[mapName], action),
                };
            default:
                return state;
            }
        }, this.tree);
    }

    reduceIdArray(idArr, action) {
        switch (action.type) {
        case CREATE:
            const payloadId = action.payload[this.schema.idAttribute];
            const newId = payloadId ? payloadId : this.nextId();
            return [...idArr, newId];
        case DELETE:
            const idsToDelete = action.payload.idArr;
            return idArr.filter(id => !idsToDelete.includes(id));
        case ORDER:
            const entities = sortByAll(this.getFullEntities(), action.payload);
            return entities.map(entity => entity[this.idAttribute]);
        default:
            return idArr;
        }
    }

    reduceEntityMap(entityMap, action) {
        switch (action.type) {
        case CREATE:
            const payloadId = action.payload[this.schema.idAttribute];
            const newId = payloadId ? payloadId : this.nextId();
            return {
                ...entityMap,
                [newId]: Object.assign({}, omit(action.payload, 'id')),
            };
        case UPDATE:
            let mapper;
            if (typeof action.payload.updater === 'function') {
                mapper = action.payload.updater;
            } else {
                mapper = entity => Object.assign({}, entity, action.payload.updater);
            }

            const updatesMap = action.payload.idArr.reduce((map, _id) => {
                map[_id] = mapper(entityMap[_id]);
                return map;
            }, {});

            return {
                ...entityMap,
                ...updatesMap,
            };
        case DELETE:
            const idsToDelete = action.payload.idArr;
            return omit(entityMap, idsToDelete);
        default:
            return entityMap;
        }
    }
};

EntityManager.prototype.querySetClass = QuerySet;
EntityManager.prototype.entityClass = Entity;

export default EntityManager;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Entity.html">Entity</a></li><li><a href="EntityManager.html">EntityManager</a></li><li><a href="QuerySet.html">QuerySet</a></li></ul><h3>Global</h3><ul><li><a href="global.html#match">match</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Wed Nov 25 2015 00:46:14 GMT-0800 (PST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
